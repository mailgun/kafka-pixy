package pixy

import (
	"fmt"
	"sort"
	"sync"
	"time"

	"github.com/mailgun/kafka-pixy/Godeps/_workspace/src/github.com/mailgun/kazoo-go"
	"github.com/mailgun/kafka-pixy/Godeps/_workspace/src/github.com/mailgun/log"
)

// ConsumerGroupRegistry maintains proper consumer group member registration
// in ZooKeeper based on the number of topics the respective consumer group
// member consumes at the moment. The list of consumed topics is managed via
// `Topics()` channel. It also watches for other group members that join/leave
// the group. Updated group member subscriptions are sent down to the
// `MembershipChanges()` channel.
type ConsumerGroupRegistry struct {
	group               string
	config              *KafkaClientCfg
	groupZNode          *kazoo.Consumergroup
	groupMemberZNode    *kazoo.ConsumergroupInstance
	topicsCh            chan []string
	membershipChangesCh chan []GroupMemberSubscription
	stoppingCh          chan none
	wg                  *sync.WaitGroup
}

func SpawnConsumerGroupRegister(group, memberID string, config *KafkaClientCfg, kazooConn *kazoo.Kazoo) *ConsumerGroupRegistry {
	groupZNode := kazooConn.Consumergroup(group)
	groupMemberZNode := groupZNode.Instance(memberID)
	cgr := &ConsumerGroupRegistry{
		group:               group,
		config:              config,
		groupZNode:          groupZNode,
		groupMemberZNode:    groupMemberZNode,
		topicsCh:            make(chan []string),
		membershipChangesCh: make(chan []GroupMemberSubscription),
		stoppingCh:          make(chan none),
		wg:                  &sync.WaitGroup{},
	}

	goGo(cgr.wg, cgr.watcher)
	goGo(cgr.wg, cgr.register)

	return cgr
}

func (cgr *ConsumerGroupRegistry) Topics() chan<- []string {
	return cgr.topicsCh
}

func (cgr *ConsumerGroupRegistry) MembershipChanges() <-chan []GroupMemberSubscription {
	return cgr.membershipChangesCh
}

func (cgr *ConsumerGroupRegistry) ClaimPartition(scope, topic string, partition int32, cancelCh <-chan none) func() {
	if !retry(func() error { return cgr.groupMemberZNode.ClaimPartition(topic, partition) }, nil,
		fmt.Sprintf("<%s> Failed to claim partition", scope), cgr.config.Consumer.BackOffTimeout, cancelCh,
	) {
		log.Infof("<%s> Partition claimed", scope)
	}
	return func() {
		if !retry(func() error { return cgr.groupMemberZNode.ReleasePartition(topic, partition) },
			func(err error) bool { return err != nil && err != kazoo.ErrPartitionNotClaimed },
			fmt.Sprintf("<%s> Failed to release partition", scope), cgr.config.Consumer.BackOffTimeout, cancelCh,
		) {
			log.Infof("<%s> Partition released", scope)
		}
	}
}

func (cgr *ConsumerGroupRegistry) Stop() {
	close(cgr.stoppingCh)
	cgr.wg.Wait()
}

func (cgr *ConsumerGroupRegistry) partitionOwner(topic string, partition int32) (string, error) {
	owner, err := cgr.groupZNode.PartitionOwner(topic, partition)
	if err != nil {
		return "", err
	}
	if owner == nil {
		return "", nil
	}
	return owner.ID, nil
}

type GroupMemberSubscription struct {
	memberID string
	topics   []string
}

// watcher keeps an eye on the consumer group membership changes, that is when
// members join/leave the group and sends notifications about such changes down
// to the `membershipChangesCh` channel.
func (cgr *ConsumerGroupRegistry) watcher() {
	scope := fmt.Sprintf("zookeeper/%s/watcher", cgr.group)
	defer logScope(scope)
	defer close(cgr.membershipChangesCh)

	if cgr.retry(cgr.groupZNode.Create, nil, fmt.Sprintf("<%s> Failed to create a group znode", scope)) {
		return
	}
watchLoop:
	for {
		var members []*kazoo.ConsumergroupInstance
		var membershipChangedCh <-chan struct{}
		if cgr.retry(
			func() error {
				var err error
				members, membershipChangedCh, err = cgr.groupZNode.WatchInstances()
				return err
			},
			nil, fmt.Sprintf("<%s> Failed to watch members", scope),
		) {
			return
		}
		// When a group member wants to update the list of topics it is
		// subscribed to, it first deregisters and then registers again to
		// ensure that ZooKeeper node watches set by other peers are triggered.
		// But that trades none notifications for two notifications coming in
		// quick succession. To avoid rebalancing triggered by the first watch
		// (generated by deregister) membership change are not handled at once,
		// but rather postponed by `Config.Consumer.RebalanceDelay`, so that if
		// another watch is triggered while waiting, it will be reacted upon.
		select {
		case <-membershipChangedCh:
			continue watchLoop
		case <-time.After(cgr.config.Consumer.RebalanceDelay):
			subscriptions := make([]GroupMemberSubscription, len(members))
			for i, member := range members {
				var registration *kazoo.Registration
				if cgr.retry(
					func() error {
						var err error
						registration, err = member.Registration()
						return err
					},
					nil, fmt.Sprintf("<%s> Failed to get member registration", scope),
				) {
					return
				}

				if registration.Pattern != kazoo.RegPatternStatic {
					log.Errorf("<%s> Usupported registration pattern: memberID=%s, pattern=%s",
						scope, member.ID, registration.Pattern)
					continue watchLoop
				}

				// Sort topics to ensure deterministic output.
				topics := make([]string, 0, len(registration.Subscription))
				for topic := range registration.Subscription {
					topics = append(topics, topic)
				}
				sort.Sort(sort.StringSlice(topics))

				subscriptions[i] = GroupMemberSubscription{member.ID, topics}
			}
			select {
			case cgr.membershipChangesCh <- subscriptions:
				log.Infof("<%s> Group subscriptions changed: %+v", scope, subscriptions)
			case <-cgr.stoppingCh:
				return
			}
		case <-cgr.stoppingCh:
			return
		}
	}
}

// register receives information about what topics the consumer group member
// is consuming at the moment via `addTopicsCh` and `deleteTopicsCh` and updates
// the member registration in ZooKeeper.
func (cgr *ConsumerGroupRegistry) register() {
	scope := fmt.Sprintf("zookeeper/%s/register", cgr.group)
	defer logScope(scope)()
	defer cgr.retry(cgr.groupMemberZNode.Deregister,
		func(err error) bool { return err != nil && err != kazoo.ErrInstanceNotRegistered },
		fmt.Sprintf("<%s> failed to deregister", scope))

	for {
		var topics []string
		select {
		case topics = <-cgr.topicsCh:
		case <-cgr.stoppingCh:
			return
		}
		sort.Sort(sort.StringSlice(topics))

		log.Infof("<%s> registering: id=%s, topics=%v", scope, cgr.groupMemberZNode.ID, topics)
		// We need to deregister first to ensure that child watches on the
		// consumer group znode set by other members are triggered when an
		// updated member registration is added.
		if cgr.retry(cgr.groupMemberZNode.Deregister,
			func(err error) bool { return err != nil && err != kazoo.ErrInstanceNotRegistered },
			fmt.Sprintf("<%s> failed to deregister", scope),
		) {
			return
		}
		if cgr.retry(func() error { return cgr.groupMemberZNode.Register(topics) },
			nil, fmt.Sprintf("<%s> failed to register", scope),
		) {
			return
		}
	}
}

func (cgr *ConsumerGroupRegistry) retry(f func() error, shouldRetry func(err error) bool, errorMsg string) (canceled bool) {
	return retry(f, shouldRetry, errorMsg, cgr.config.Consumer.BackOffTimeout, cgr.stoppingCh)
}
